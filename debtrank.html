<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulating DebtRank</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* Tailwind gray-50 */
        }
        canvas {
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
        }
        .tab-btn {
            transition: all 0.2s ease-in-out;
        }
        .tab-btn.active {
            border-color: #4f46e5; /* Indigo-600 */
            background-color: #eef2ff; /* Indigo-50 */
            color: #4338ca; /* Indigo-800 */
            font-weight: 600;
        }
        .bs-table {
            width: 100%;
            border-collapse: collapse;
        }
        .bs-table th, .bs-table td {
            text-align: left;
            padding: 4px 8px;
            border-bottom: 1px solid #e5e7eb;
        }
        .bs-table th {
            background-color: #f9fafb;
        }
        .bs-table .total-row {
            font-weight: bold;
            border-top: 2px solid #d1d5db;
        }
    </style>
</head>
<body class="text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">Simulating DebtRank</h1>
        </header>

        <!-- Scenario Tabs -->
        <div id="scenario-tabs" class="mb-8 flex items-center justify-center border-b border-gray-200">
            <!-- Tabs will be inserted here by script -->
        </div>

        <!-- Controls -->
        <div class="bg-white p-6 rounded-lg shadow-md mb-8 max-w-5xl mx-auto">
            <div class="flex flex-col sm:flex-row flex-wrap items-center justify-center gap-4">
                <label for="shock-bank" class="text-md font-medium text-gray-700">Shock node:</label>
                <select id="shock-bank" class="block w-full sm:w-auto mt-1 rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"></select>
                <button id="run-simulation" class="w-full sm:w-auto bg-green-600 text-white font-semibold py-2 px-6 rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-colors duration-200">
                    Run All
                </button>
                <button id="next-step-simulation" class="w-full sm:w-auto bg-green-600 text-white font-semibold py-2 px-6 rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-colors duration-200">
                    Next Step
                </button>
                <button id="reset-simulation" class="w-full sm:w-auto bg-gray-600 text-white font-semibold py-2 px-6 rounded-lg hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors duration-200">
                    Reset
                </button>
                <button id="import-network" class="w-full sm:w-auto bg-blue-600 text-white font-semibold py-2 px-6 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors duration-200">
                    Import
                </button>
                <button id="export-network" class="w-full sm:w-auto bg-blue-600 text-white font-semibold py-2 px-6 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors duration-200">
                    Export
                </button>
            </div>
        </div>


        <!-- Visualization -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <!-- Network Visualization -->
            <div class="w-full">
                <h2 class="text-xl font-semibold mb-4 text-center">Network State</h2>
                <canvas id="networkCanvas"></canvas>
            </div>
            <!-- Results Plot -->
            <div class="w-full">
                <h2 class="text-xl font-semibold mb-4 text-center">Contagion Rounds</h2>
                <canvas id="plotCanvas"></canvas>
            </div>
        </div>
        
        <!-- Log Output -->
        <div class="mt-8 bg-white p-6 rounded-lg shadow-md max-w-4xl mx-auto">
            <h2 class="text-xl font-semibold mb-4">Round-by-Round Log</h2>
            <div id="log" class="text-sm font-mono text-gray-700 bg-gray-50 p-4 rounded-md h-48 overflow-y-auto">
                <p>Simulation log will appear here...</p>
            </div>
        </div>

        <!-- Detailed Balance Sheet Logs -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mt-8">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-semibold mb-4 text-center">Detailed Balance Sheet: C3</h2>
                <div id="c3-bs-log" class="text-sm font-mono text-gray-700 bg-gray-50 p-4 rounded-md h-96 overflow-y-auto">
                    <p>Detailed log for C3 will appear here...</p>
                </div>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-semibold mb-4 text-center">Detailed Balance Sheet: P4</h2>
                <div id="p4-bs-log" class="text-sm font-mono text-gray-700 bg-gray-50 p-4 rounded-md h-96 overflow-y-auto">
                    <p>Detailed log for P4 will appear here...</p>
                </div>
            </div>
        </div>

        <!-- Balance Sheet Info -->
        <div id="balance-sheet-info" class="mt-8 bg-white p-6 rounded-lg shadow-md max-w-5xl mx-auto">
            <h2 class="text-xl font-semibold mb-4 text-center">Initial Balance Sheet Summary</h2>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Node</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">External Assets</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Inter-entity Assets</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Inter-entity Liabilities</th>
                             <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Equity</th>
                        </tr>
                    </thead>
                    <tbody id="balance-sheet-body" class="bg-white divide-y divide-gray-200">
                        <!-- Rows will be inserted here by script -->
                    </tbody>
                </table>
            </div>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- 1. DATA SETUP ---
            const scenarios = {
                'bipartite': {
                    name: "Bipartite (Pools & Users)",
                    algorithm: 'standard',
                    banks: {
                        'P1': { id: 'P1', name: "Pool 1", equity: 150, externalAssets: 100, pos: { x: 0.25, y: 0.2 } },
                        'P2': { id: 'P2', name: "Pool 2", equity: 200, externalAssets: 120, pos: { x: 0.5, y: 0.2 } },
                        'P3': { id: 'P3', name: "Pool 3", equity: 180, externalAssets: 110, pos: { x: 0.75, y: 0.2 } },
                        'U1': { id: 'U1', name: "User 1", equity: 40, externalAssets: 20, pos: { x: 0.1, y: 0.8 } },
                        'U2': { id: 'U2', name: "User 2", equity: 50, externalAssets: 30, pos: { x: 0.23, y: 0.8 } },
                        'U3': { id: 'U3', name: "User 3", equity: 30, externalAssets: 15, pos: { x: 0.36, y: 0.8 } },
                        'U4': { id: 'U4', name: "User 4", equity: 35, externalAssets: 25, pos: { x: 0.49, y: 0.8 } },
                        'U5': { id: 'U5', name: "User 5", equity: 60, externalAssets: 40, pos: { x: 0.62, y: 0.8 } },
                        'U6': { id: 'U6', name: "User 6", equity: 25, externalAssets: 10, pos: { x: 0.75, y: 0.8 } },
                        'U7': { id: 'U7', name: "User 7", equity: 45, externalAssets: 22, pos: { x: 0.88, y: 0.8 } }
                    },
                    liabilities: { // Creditor: { Debtor: Amount }
                        // Pools lending to Users
                        'P1': { 'U1': 30, 'U2': 40, 'U5': 50 },
                        'P2': { 'U2': 20, 'U3': 25, 'U6': 20, 'U7': 30 },
                        'P3': { 'U1': 15, 'U4': 30, 'U5': 40, 'U7': 20 },
                        // Users lending to Pools
                        'U1': { 'P2': 25 },
                        'U4': { 'P1': 15 },
                        'U5': { 'P1': 10, 'P2': 10 },
                        'U7': { 'P3': 35 }
                    }
                },
                'acyclic-standard': {
                    name: "Unipartite Core-Periphery",
                    algorithm: 'standard',
                    banks: {
                        'C1': { id: 'C1', name: "Core Bank 1", equity: 100, externalAssets: 60, pos: { x: 0.4, y: 0.4 } },
                        'C2': { id: 'C2', name: "Core Bank 2", equity: 120, externalAssets: 60, pos: { x: 0.6, y: 0.4 } },
                        'C3': { id: 'C3', name: "Core Bank 3", equity: 80, externalAssets: 80, pos: { x: 0.5, y: 0.6 } },
                        'P1': { id: 'P1', name: "Periph Bank 1", equity: 30, externalAssets: 50, pos: { x: 0.2, y: 0.2 } },
                        'P2': { id: 'P2', name: "Periph Bank 2", equity: 40, externalAssets: 65, pos: { x: 0.8, y: 0.2 } },
                        'P3': { id: 'P3', name: "Periph Bank 3", equity: 25, externalAssets: 40, pos: { x: 0.8, y: 0.8 } },
                        'P4': { id: 'P4', name: "Periph Bank 4", equity: 35, externalAssets: 55, pos: { x: 0.2, y: 0.8 } },
                        'P5': { id: 'P5', name: "Periph Bank 5", equity: 20, externalAssets: 30, pos: { x: 0.1, y: 0.5 } },
                        'P6': { id: 'P6', name: "Periph Bank 6", equity: 30, externalAssets: 55, pos: { x: 0.9, y: 0.5 } },
                        'P7': { id: 'P7', name: "Periph Bank 7", equity: 22, externalAssets: 7, pos: { x: 0.5, y: 0.1 } },
                    },
                    liabilities: { // Creditor: { Debtor: Amount }
                        'C1': { 'C2': 70, 'C3': 50, 'P1': 30, 'P5': 20 },
                        'C2': { 'C1': 60, 'C3': 80, 'P2': 40, 'P6': 30 },
                        'C3': { 'C1': 40, 'C2': 50, 'P3': 25, 'P4': 30 },
                        'P1': { 'C3': 10 },
                        'P2': { 'C1': 15 },
                        'P3': { 'C2': 10 },
                        'P4': { 'C1': 10 },
                        'P5': { 'C2': 10 },
                        'P6': { 'C3': 5 },
                        'P7': { 'C1': 5, 'C2': 10 },
                    }
                },
                'acyclic-no-reinfect': {
                    name: "Unipartite CP (No Reinfection)",
                    algorithm: 'no-reinfection',
                    banks: { // Same network as standard
                        'C1': { id: 'C1', name: "Core Bank 1", equity: 100, externalAssets: 60, pos: { x: 0.4, y: 0.4 } },
                        'C2': { id: 'C2', name: "Core Bank 2", equity: 120, externalAssets: 60, pos: { x: 0.6, y: 0.4 } },
                        'C3': { id: 'C3', name: "Core Bank 3", equity: 80, externalAssets: 80, pos: { x: 0.5, y: 0.6 } },
                        'P1': { id: 'P1', name: "Periph Bank 1", equity: 30, externalAssets: 50, pos: { x: 0.2, y: 0.2 } },
                        'P2': { id: 'P2', name: "Periph Bank 2", equity: 40, externalAssets: 65, pos: { x: 0.8, y: 0.2 } },
                        'P3': { id: 'P3', name: "Periph Bank 3", equity: 25, externalAssets: 40, pos: { x: 0.8, y: 0.8 } },
                        'P4': { id: 'P4', name: "Periph Bank 4", equity: 35, externalAssets: 55, pos: { x: 0.2, y: 0.8 } },
                        'P5': { id: 'P5', name: "Periph Bank 5", equity: 20, externalAssets: 30, pos: { x: 0.1, y: 0.5 } },
                        'P6': { id: 'P6', name: "Periph Bank 6", equity: 30, externalAssets: 55, pos: { x: 0.9, y: 0.5 } },
                        'P7': { id: 'P7', name: "Periph Bank 7", equity: 22, externalAssets: 7, pos: { x: 0.5, y: 0.1 } },
                    },
                    liabilities: { // Same liabilities as standard
                        'C1': { 'C2': 70, 'C3': 50, 'P1': 30, 'P5': 20 },
                        'C2': { 'C1': 60, 'C3': 80, 'P2': 40, 'P6': 30 },
                        'C3': { 'C1': 40, 'C2': 50, 'P3': 25, 'P4': 30 },
                        'P1': { 'C3': 10 },
                        'P2': { 'C1': 15 },
                        'P3': { 'C2': 10 },
                        'P4': { 'C1': 10 },
                        'P5': { 'C2': 10 },
                        'P6': { 'C3': 5 },
                        'P7': { 'C1': 5, 'C2': 10 },
                    }
                }
            };
            
            // --- 2. STATE & UI VARIABLES ---
            let currentScenarioId = 'bipartite';
            let banks = {};
            let liabilities = {};
            let initialBanks = {};
            let initialLiabilities = {};

            // Simulation state variables
            let simulationInProgress = false;
            let activeShockPropagators = [];
            let round = 0;

            const selectEl = document.getElementById('shock-bank');
            const runBtn = document.getElementById('run-simulation');
            const nextStepBtn = document.getElementById('next-step-simulation');
            const logEl = document.getElementById('log');
            const resetBtn = document.getElementById('reset-simulation');
            const importBtn = document.getElementById('import-network');
            const exportBtn = document.getElementById('export-network');
            const scenarioTabsEl = document.getElementById('scenario-tabs');
            const c3BsLogEl = document.getElementById('c3-bs-log');
            const p4BsLogEl = document.getElementById('p4-bs-log');

            const netCanvas = document.getElementById('networkCanvas');
            const netCtx = netCanvas.getContext('2d');
            const plotCanvas = document.getElementById('plotCanvas');
            const plotCtx = plotCanvas.getContext('2d');

            const stateColors = {
                U: 'rgb(34, 197, 94)',   // green-500
                D: 'rgb(249, 115, 22)',  // orange-500
                I: 'rgb(239, 68, 68)',   // red-500
            };
            
            let simulationData = { plotData: [] };

            // --- 3. CORE DEBTRANK ALGORITHM ---
            function resetState() {
                Object.values(banks).forEach(bank => {
                    bank.state = 'U'; // U: Undistressed
                    bank.h = 0;       // Distress level (0 to 1)
                });
            }

            function startSimulation() {
                const shockedBankId = selectEl.value;
                if (!shockedBankId) {
                    logMessage("Please select a node to shock.");
                    return false;
                }
                
                logEl.innerHTML = '';
                c3BsLogEl.innerHTML = '<p>Detailed log for C3 will appear here...</p>';
                p4BsLogEl.innerHTML = '<p>Detailed log for P4 will appear here...</p>';
                logMessage(`--- Starting Simulation: Shocking ${banks[shockedBankId].name} ---`);
                
                // Use a fresh copy of the initial state for the simulation run
                banks = JSON.parse(JSON.stringify(initialBanks));
                liabilities = JSON.parse(JSON.stringify(initialLiabilities));
                resetState();
                
                banks[shockedBankId].state = 'D';
                banks[shockedBankId].h = 1.0;

                activeShockPropagators = [shockedBankId];
                round = 0;
                simulationData.plotData = [];

                recordRoundStats(simulationData.plotData, round);
                logMessage(`Round 0: ${banks[shockedBankId].name} is initially distressed.`);
                
                if (banks['C3'] && banks['P4']) updateDetailedBalanceSheets(round);
                drawNetwork();
                drawPlot(simulationData.plotData);

                simulationInProgress = true;
                return true;
            }

            function runSingleStep() {
                if (!simulationInProgress || activeShockPropagators.length === 0 || round >= 15) {
                    if (simulationInProgress) logMessage('--- Simulation Complete ---');
                    simulationInProgress = false;
                    return false; // Can't step, simulation is over
                }

                round++;
                let newlyDistressed = new Set();
                let shockReceivers = {};

                activeShockPropagators.forEach(debtorId => {
                    const shockLevel = banks[debtorId].h;
                    if (shockLevel <= 0) return;
                    
                    Object.keys(liabilities).forEach(creditorId => {
                        const loan = liabilities[creditorId][debtorId] || 0;
                        if (loan > 0) {
                            const impact = (loan / banks[creditorId].equity) * shockLevel;
                            shockReceivers[creditorId] = (shockReceivers[creditorId] || 0) + impact;
                        }
                    });
                });

                logMessage(`Round ${round}: Propagating shocks...`);
                
                const currentAlgorithm = scenarios[currentScenarioId].algorithm;

                Object.keys(shockReceivers).forEach(bankId => {
                    const bank = banks[bankId];
                    const totalImpact = shockReceivers[bankId];

                    if (bank.state === 'I') return;

                    let applyShock = true;
                    if (currentAlgorithm === 'no-reinfection' && bank.state !== 'U') {
                        applyShock = false;
                    }

                    if (applyShock) {
                        const old_h = bank.h;
                        bank.h = Math.min(1, bank.h + totalImpact);

                        if (bank.h > old_h) {
                            if (bank.h >= 1) {
                                bank.state = 'I';
                                logMessage(`  - ${bank.name} has FAILED (Equity wiped out).`);
                            } else {
                                bank.state = 'D';
                                logMessage(`  - ${bank.name} is now distressed with loss ${Math.round(bank.h*100)}%.`);
                            }
                            newlyDistressed.add(bankId);
                        }
                    }
                });

                activeShockPropagators = Array.from(newlyDistressed);
                recordRoundStats(simulationData.plotData, round);
                if (banks['C3'] && banks['P4']) updateDetailedBalanceSheets(round);
                
                if (activeShockPropagators.length === 0) {
                    logMessage(`Round ${round}: No new distress. Contagion stabilized.`);
                }
                
                drawNetwork();
                drawPlot(simulationData.plotData);
                return true; // Step was successful
            }
            
            function handleRunAllClick() {
                if (startSimulation()) {
                    while (runSingleStep()) { /* Loop until complete */ }
                }
            }

            function handleNextStepClick() {
                if (!simulationInProgress) {
                    startSimulation();
                } else {
                    runSingleStep();
                }
            }


            // --- 4. VISUALIZATION & LOGGING FUNCTIONS ---

            function drawNetwork() {
                netCtx.clearRect(0, 0, netCanvas.width, netCanvas.height);
                if (!netCanvas.width || Object.keys(banks).length === 0) return;
                const bankRadius = netCanvas.width / 40; 

                let maxExposure = 0;
                Object.values(liabilities).forEach(creditorLiabilities => {
                    Object.values(creditorLiabilities).forEach(loan => {
                        if (loan > maxExposure) maxExposure = loan;
                    });
                });
                if (maxExposure === 0) maxExposure = 1;

                netCtx.strokeStyle = '#9ca3af';
                
                Object.keys(liabilities).forEach(creditorId => {
                    Object.keys(liabilities[creditorId]).forEach(debtorId => {
                        const creditor = banks[creditorId];
                        const debtor = banks[debtorId];
                        if (!creditor || !debtor) return;
                        const loan = liabilities[creditorId][debtorId] || 0;

                        const minWidth = 1;
                        const maxWidth = 7;
                        netCtx.lineWidth = minWidth + (loan / maxExposure) * (maxWidth - minWidth);
                        
                        const creditorPos = { x: creditor.pos.x * netCanvas.width, y: creditor.pos.y * netCanvas.height };
                        const debtorPos = { x: debtor.pos.x * netCanvas.width, y: debtor.pos.y * netCanvas.height };

                        const angle = Math.atan2(creditorPos.y - debtorPos.y, creditorPos.x - debtorPos.x);
                        
                        const startX = debtorPos.x + bankRadius * Math.cos(angle);
                        const startY = debtorPos.y + bankRadius * Math.sin(angle);
                        const endX = creditorPos.x - bankRadius * Math.cos(angle);
                        const endY = creditorPos.y - bankRadius * Math.sin(angle);
                        
                        netCtx.beginPath();
                        netCtx.moveTo(startX, startY);
                        netCtx.lineTo(endX, endY);
                        netCtx.stroke();
                        
                        const arrowSize = netCtx.lineWidth * 2.5;
                        netCtx.save();
                        netCtx.translate(endX, endY);
                        netCtx.rotate(angle);
                        netCtx.beginPath();
                        netCtx.moveTo(-arrowSize, -arrowSize / 2);
                        netCtx.lineTo(0, 0);
                        netCtx.lineTo(-arrowSize, arrowSize / 2);
                        netCtx.fillStyle = '#9ca3af';
                        netCtx.fill();
                        netCtx.restore();
                    });
                });
                
                Object.values(banks).forEach(bank => {
                    const bankPos = { x: bank.pos.x * netCanvas.width, y: bank.pos.y * netCanvas.height };

                    netCtx.beginPath();
                    netCtx.arc(bankPos.x, bankPos.y, bankRadius, 0, Math.PI * 2);
                    netCtx.fillStyle = stateColors[bank.state];
                    netCtx.fill();
                    netCtx.strokeStyle = 'rgba(0,0,0,0.5)';
                    netCtx.lineWidth = 2;
                    netCtx.stroke();
                    
                    netCtx.fillStyle = 'white';
                    netCtx.font = `bold ${bankRadius * 0.75}px Inter`;
                    netCtx.textAlign = 'center';
                    netCtx.textBaseline = 'middle';
                    netCtx.fillText(bank.id, bankPos.x, bankPos.y);
                });
            }

            function drawPlot(data) {
                plotCtx.clearRect(0, 0, plotCanvas.width, plotCanvas.height);
                const padding = 50;
                const width = plotCanvas.width - 2 * padding;
                const height = plotCanvas.height - 2 * padding;

                if (width <= 0 || !data || Object.keys(banks).length === 0) return;
                
                let maxRounds = data.length > 1 ? data[data.length - 1].round : 1;
                if (maxRounds === 0 && data.length > 0) maxRounds = 1;

                const maxCount = Object.keys(banks).length;

                plotCtx.beginPath();
                plotCtx.strokeStyle = '#6b7280';
                plotCtx.moveTo(padding, padding);
                plotCtx.lineTo(padding, padding + height);
                plotCtx.lineTo(padding + width, padding + height);
                plotCtx.stroke();

                plotCtx.fillStyle = '#4b5563';
                plotCtx.textAlign = 'right';
                plotCtx.textBaseline = 'middle';
                for (let i = 0; i <= maxCount; i++) {
                    if (i % (Math.ceil(maxCount/10)) === 0) {
                        const y = padding + height - (i / maxCount) * height;
                        plotCtx.fillText(i, padding - 10, y);
                    }
                }
                plotCtx.save();
                plotCtx.translate(padding - 35, padding + height/2);
                plotCtx.rotate(-Math.PI/2);
                plotCtx.textAlign = 'center';
                plotCtx.fillText("Number of Nodes", 0, 0);
                plotCtx.restore();

                plotCtx.textAlign = 'center';
                plotCtx.textBaseline = 'top';
                for (let i = 0; i <= maxRounds; i++) {
                     const x = padding + (i / maxRounds) * width;
                    plotCtx.fillText(i, x, padding + height + 10);
                }
                plotCtx.fillText("Round", padding + width/2, padding + height + 30);

                const plotLine = (key, color) => {
                    plotCtx.beginPath();
                    plotCtx.strokeStyle = color;
                    plotCtx.lineWidth = 2;
                    data.forEach((d, i) => {
                        const x = padding + (d.round / maxRounds) * width;
                        const y = padding + height - (d[key] / maxCount) * height;
                        if (i === 0) plotCtx.moveTo(x, y);
                        else plotCtx.lineTo(x, y);
                    });
                    plotCtx.stroke();
                };

                plotLine('distressedCount', stateColors.D);
                plotLine('failedCount', stateColors.I);
                
                plotCtx.fillStyle = stateColors.D;
                plotCtx.fillRect(padding + 50, 15, 15, 10);
                plotCtx.fillStyle = '#4b5563';
                plotCtx.textAlign = 'left';
                plotCtx.fillText('Distressed (incl. Failed)', padding + 70, 20);

                plotCtx.fillStyle = stateColors.I;
                plotCtx.fillRect(padding + 220, 15, 15, 10);
                plotCtx.fillStyle = '#4b5563';
                plotCtx.fillText('Failed', padding + 240, 20);
            }

            function updateDetailedBalanceSheets(round) {
                ['C3', 'P4'].forEach(bankId => {
                    if (!banks[bankId] || !initialBanks[bankId]) return;
                    
                    const logEl = bankId === 'C3' ? c3BsLogEl : p4BsLogEl;
                    const initialBank = initialBanks[bankId];
                    if (!initialBank) return;

                    // --- Assets ---
                    let currentInterbankAssets = 0;
                    let assetsHtml = `<tr><td>External Assets</td><td>${initialBank.externalAssets.toFixed(2)}</td></tr>`;
                    if (initialLiabilities[bankId]) {
                        Object.keys(initialLiabilities[bankId]).forEach(debtorId => {
                            const initialLoan = initialLiabilities[bankId][debtorId];
                            const currentLoanValue = initialLoan * (1 - banks[debtorId].h);
                            currentInterbankAssets += currentLoanValue;
                            assetsHtml += `<tr><td>Loan to ${debtorId}</td><td>${currentLoanValue.toFixed(2)}</td></tr>`;
                        });
                    }
                    const totalAssets = initialBank.externalAssets + currentInterbankAssets;
                    
                    // --- Liabilities ---
                    let totalInterbankLiabilities = 0;
                    let liabilitiesHtml = '';
                    Object.keys(initialLiabilities).forEach(creditorId => {
                        if (initialLiabilities[creditorId][bankId]) {
                            const loan = initialLiabilities[creditorId][bankId];
                            totalInterbankLiabilities += loan;
                            liabilitiesHtml += `<tr><td>Loan from ${creditorId}</td><td>${loan.toFixed(2)}</td></tr>`;
                        }
                    });
                    
                    const currentEquity = totalAssets - totalInterbankLiabilities;

                    const roundHtml = `
                        <div class="mb-4">
                            <h4 class="font-bold">Round ${round} (Distress: ${(banks[bankId].h * 100).toFixed(1)}%)</h4>
                            <table class="bs-table mt-2">
                                <thead><tr><th>Assets</th><th>Value</th></tr></thead>
                                <tbody>${assetsHtml}<tr class="total-row"><td>Total Assets</td><td>${totalAssets.toFixed(2)}</td></tr></tbody>
                            </table>
                            <table class="bs-table mt-2">
                                <thead><tr><th>Liabilities & Equity</th><th>Value</th></tr></thead>
                                <tbody>
                                    ${liabilitiesHtml}
                                    <tr class="total-row" style="color: ${currentEquity < 0 ? stateColors.I : 'inherit'};">
                                        <td>Equity</td>
                                        <td>${Math.max(0, currentEquity).toFixed(2)}</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    `;
                    if (round === 0) {
                        logEl.innerHTML = roundHtml;
                    } else {
                        logEl.innerHTML += roundHtml;
                    }
                    logEl.scrollTop = logEl.scrollHeight;
                });
            }
            
            // --- 5. UTILITY & INITIALIZATION ---

            function recordRoundStats(data, round) {
                const stats = {
                    round: round,
                    distressedCount: Object.values(banks).filter(b => b.state === 'D' || b.state === 'I').length,
                    failedCount: Object.values(banks).filter(b => b.state === 'I').length,
                };
                data.push(stats);
            }

            function logMessage(msg) {
                const p = document.createElement('p');
                p.textContent = msg;
                logEl.appendChild(p);
                logEl.scrollTop = logEl.scrollHeight;
            }
            
            function populateDropdown() {
                selectEl.innerHTML = '';
                Object.values(banks).forEach(bank => {
                    const option = document.createElement('option');
                    option.value = bank.id;
                    option.textContent = `${bank.name} (${bank.id})`;
                    selectEl.appendChild(option);
                });
            }

            function displayBalanceSheets() {
                const tbody = document.getElementById('balance-sheet-body');
                tbody.innerHTML = '';

                Object.values(banks).forEach(bank => {
                    let totalInterbankAssets = 0;
                    if(initialLiabilities[bank.id]){
                        totalInterbankAssets = Object.values(initialLiabilities[bank.id]).reduce((sum, val) => sum + val, 0);
                    }

                    let totalInterbankLiabilities = 0;
                    Object.keys(initialLiabilities).forEach(creditorId => {
                        if (initialLiabilities[creditorId][bank.id]) {
                            totalInterbankLiabilities += initialLiabilities[creditorId][bank.id];
                        }
                    });
                    
                    const row = `
                        <tr class="text-sm">
                            <td class="px-6 py-4 whitespace-nowrap font-medium text-gray-900">${bank.name} (${bank.id})</td>
                            <td class="px-6 py-4 whitespace-nowrap text-gray-500">${bank.externalAssets}</td>
                            <td class="px-6 py-4 whitespace-nowrap text-gray-500">${totalInterbankAssets}</td>
                            <td class="px-6 py-4 whitespace-nowrap text-gray-500">${totalInterbankLiabilities}</td>
                            <td class="px-6 py-4 whitespace-nowrap text-gray-500">${bank.equity}</td>
                        </tr>
                    `;
                    tbody.innerHTML += row;
                });
            }

            function exportNetwork() {
                const scenario = scenarios[currentScenarioId];
                
                const nodes = Object.values(initialBanks).map(bank => {
                    const interbankAssets = initialLiabilities[bank.id] || {};
                    const interbankLiabilities = {};
                    Object.keys(initialLiabilities).forEach(creditorId => {
                        if (initialLiabilities[creditorId][bank.id]) {
                            interbankLiabilities[creditorId] = initialLiabilities[creditorId][bank.id];
                        }
                    });

                    return {
                        id: bank.id,
                        name: bank.name,
                        position: bank.pos,
                        balanceSheet: {
                            equity: bank.equity,
                            externalAssets: bank.externalAssets,
                            interbankAssets: interbankAssets, // loans to others
                            interbankLiabilities: interbankLiabilities // loans from others
                        }
                    };
                });

                const links = [];
                Object.keys(initialLiabilities).forEach(creditorId => {
                    Object.keys(initialLiabilities[creditorId]).forEach(debtorId => {
                        links.push({
                            source: debtorId, // who owes
                            target: creditorId, // who is owed
                            value: initialLiabilities[creditorId][debtorId]
                        });
                    });
                });

                const exportData = {
                    scenarioName: scenario.name,
                    algorithm: scenario.algorithm,
                    nodes: nodes,
                    links: links
                };

                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportData, null, 2));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                const filename = scenario.name.replace(/[^a-z0-9_]/gi, '-').toLowerCase() + '.json';
                downloadAnchorNode.setAttribute("download", filename);
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
            }

            function importNetwork(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (!data.nodes || !data.links) {
                            throw new Error("Invalid JSON structure.");
                        }

                        const newBanks = {};
                        data.nodes.forEach(node => {
                            newBanks[node.id] = {
                                id: node.id,
                                name: node.name,
                                equity: node.balanceSheet.equity,
                                externalAssets: node.balanceSheet.externalAssets,
                                pos: node.position
                            };
                        });

                        // --- FIX: Check for unipartite networks and generate a better layout ---
                        const nodeIds = Object.keys(newBanks);
                        const isUnipartite = nodeIds.every(id => !id.startsWith('P') && !id.startsWith('C'));

                        if (isUnipartite && nodeIds.length > 0) {
                            logMessage("Unipartite network detected. Generating a circular layout.");
                            const n = nodeIds.length;
                            const radius = 0.35;
                            const centerX = 0.5;
                            const centerY = 0.5;
                            
                            nodeIds.forEach((nodeId, i) => {
                                const angle = (i / n) * 2 * Math.PI;
                                newBanks[nodeId].pos = {
                                    x: centerX + radius * Math.cos(angle),
                                    y: centerY + radius * Math.sin(angle)
                                };
                            });
                        }
                        // --- END FIX ---

                        const newLiabilities = {};
                        data.links.forEach(link => {
                            const creditorId = link.target;
                            const debtorId = link.source;
                            if (!newLiabilities[creditorId]) {
                                newLiabilities[creditorId] = {};
                            }
                            newLiabilities[creditorId][debtorId] = link.value;
                        });

                        const scenarioId = 'imported-scenario';
                        scenarios[scenarioId] = {
                            name: "Imported Scenario", // Use a fixed name to avoid confusion
                            algorithm: data.algorithm || 'standard',
                            banks: newBanks,
                            liabilities: newLiabilities
                        };

                        // Remove old imported tab if it exists
                        const oldTab = document.querySelector(`[data-scenario-id="${scenarioId}"]`);
                        if(oldTab) oldTab.remove();

                        // Add new tab
                        const btn = document.createElement('button');
                        btn.dataset.scenarioId = scenarioId;
                        btn.className = 'tab-btn -mb-px border-b-2 border-transparent px-4 py-3 text-sm font-medium text-gray-500 hover:border-gray-300 hover:text-gray-700';
                        btn.textContent = scenarios[scenarioId].name;
                        scenarioTabsEl.appendChild(btn);

                        switchScenario(scenarioId);
                        logMessage(`Successfully imported scenario: ${scenarios[scenarioId].name}`);

                    } catch (error) {
                        logMessage("Error importing file: " + error.message);
                    }
                };
                reader.readAsText(file);
                // Reset file input to allow importing the same file again
                event.target.value = '';
            }


            function resetSimulation() {
                logEl.innerHTML = '<p>Select a node and click "Run Simulation" to begin.</p>';
                c3BsLogEl.innerHTML = '<p>Detailed log for C3 will appear here...</p>';
                p4BsLogEl.innerHTML = '<p>Detailed log for P4 will appear here...</p>';
                
                simulationInProgress = false;
                activeShockPropagators = [];
                round = 0;

                banks = JSON.parse(JSON.stringify(initialBanks));
                liabilities = JSON.parse(JSON.stringify(initialLiabilities));
                resetState();
                simulationData.plotData = [];
                drawNetwork();
                drawPlot([]);
                if (banks['C3'] && banks['P4']) updateDetailedBalanceSheets(0); 
            }

            function switchScenario(scenarioId) {
                currentScenarioId = scenarioId;
                const scenario = scenarios[scenarioId];
                initialBanks = JSON.parse(JSON.stringify(scenario.banks));
                initialLiabilities = JSON.parse(JSON.stringify(scenario.liabilities));
                
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.scenarioId === scenarioId);
                });
                
                resetSimulation();
                populateDropdown();
                displayBalanceSheets();
                
                const detailedLogsContainer = document.querySelector('#c3-bs-log').parentElement.parentElement;
                if (scenarioId === 'bipartite' || scenarioId === 'imported-scenario') {
                    detailedLogsContainer.style.display = 'none';
                } else {
                    detailedLogsContainer.style.display = 'grid';
                }
            }
            
            function initialize() {
                Object.keys(scenarios).forEach(id => {
                    const scenario = scenarios[id];
                    const btn = document.createElement('button');
                    btn.dataset.scenarioId = id;
                    btn.className = 'tab-btn -mb-px border-b-2 border-transparent px-4 py-3 text-sm font-medium text-gray-500 hover:border-gray-300 hover:text-gray-700';
                    btn.textContent = scenario.name;
                    scenarioTabsEl.appendChild(btn);
                });

                // Setup file input for import
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.json';
                fileInput.style.display = 'none';
                fileInput.addEventListener('change', importNetwork);
                document.body.appendChild(fileInput);


                scenarioTabsEl.addEventListener('click', (e) => {
                    if (e.target.matches('.tab-btn')) {
                        switchScenario(e.target.dataset.scenarioId);
                    }
                });

                runBtn.addEventListener('click', handleRunAllClick);
                nextStepBtn.addEventListener('click', handleNextStepClick);
                resetBtn.addEventListener('click', resetSimulation);
                importBtn.addEventListener('click', () => fileInput.click());
                exportBtn.addEventListener('click', exportNetwork);
                
                function setCanvasSizes() {
                    const aspectRatio = 1;
                    const container = document.querySelector('#networkCanvas').parentElement;
                    const width = container.clientWidth;
                    const height = width * aspectRatio;
                    [netCanvas, plotCanvas].forEach(c => {
                        c.width = width;
                        c.height = height;
                    });
                }

                window.addEventListener('resize', () => {
                    setCanvasSizes();
                    drawNetwork();
                    drawPlot(simulationData.plotData);
                });

                setCanvasSizes();
                switchScenario(currentScenarioId); 
            }

            initialize();
        });
    </script>
</body>
</html>



